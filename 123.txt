#строчки в руби в puts"" не происходит экранирование и можно использовать специальные символы (например \ для перевода строки) и они будут приминены, а в puts'' будет экраноровано и выведено как есть, в одну строку не учитывая спец символы 
#для того, что бы в стройку вставить какой то значение можно использовать интерполяцию (когда строчка собирается из разных кусков) в руби это делается только в "" через #{}. к примеру  a = 123 puts "aasdsa #{a}"
a += "12" прибавляет строчку, а не количество, приводит к копированию строк и будут потери по памяти. Копирование строк НЕ ОК
a<< "123" так же прибавляет строку, но этот медон намного экономичней.
можно брать часть символов какого то значение через puts "asdasdasd"[0,3] к примеру. Последний эллемент -1. a[3, 5] означает: взять 5 элементов начиная с третьего индекса.
a == b  сравнение
solution =:symbol Переходит строку в тип данных symbol. особый тип данный - символ. Используется как идентификатор, почти как в строка. Храняться в единственном экземпляре
a = [] определили пустой массив, внутрь можно затолкать что угодно. Буквы надо в ""
Команды с ! изменяют сам массив, команды без ! создают новый массив 
если сделать a - b, то из массива a будут убраны те символы, что встречаются в массиве b. Можно взять только уникальные эллекменты в обоих массивках a | b. Эллементы в обоих вариантвх & 
a.delete убирает эллемент из массива a.delete(:a) удаляет символ a 
a[2] = 3 заменяет третий эллемент массива на цифру 3 (отчет эллементов массива начинается с 0)
a.delete_at(1) удаляет второй эллемент из массива
a1, a2 = a присваивает эллементам свой массив a1 и a2 соответственно, надо привязывать сразу все эллементы массива
c1, *c2 =a все эллементы массива a ставновятся массивом c2
(1..5).to_a создает массив с диапазонов от 1 до 5 включительно, если использовать ... последнее значение не будет включени. ('a'..'z').to_a раскрывает алфавит
ассоциативный массив h = {}
h.has_key? :hasgname узнает действительно ли был такой ключ, если к примеру у него значение nil